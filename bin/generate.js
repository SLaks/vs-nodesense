"use strict";

// Get globals before require()ing any modules, in case they leak globals
var nodeGlobals = Object.getOwnPropertyNames(global);

var fs = require('fs');
var path = require('path');
var _ = require('lodash');
var mkdirp = require('mkdirp');
var rimraf = require('rimraf');

var ModuleEmitter = require('./ModuleEmitter');
var JSWriter = require('./JSWriter');

var projectDir = './';


var outputDir = projectDir + 'node_modules/.vs-nodesense/';
rimraf.sync(outputDir);

var builtinsDir = outputDir + 'builtin-source/';
mkdirp.sync(builtinsDir);

fs.writeFile(outputDir + '.jshintignore', 'builtin-source/**');

var refGen = new ModuleEmitter(projectDir, outputDir);

function referenceTemplateFile(name) {
	var src = path.resolve(__dirname + '/../templates/' + name);
	var dest = outputDir + name;
	fs.createReadStream(src).pipe(fs.createWriteStream(dest));
	indexJS.writeReference(dest);
}

var indexJS = new JSWriter(outputDir + 'Node.js');
indexJS.writeline('// This file is generated by vs-nodesense.');
indexJS.writeline('// Add this file to your Scripts/_references.js to enable IntelliSense.\r\n');
referenceTemplateFile('reset-globals.js');
referenceTemplateFile('module.js');
indexJS.writeReference(refGen.referenceListFile);
referenceTemplateFile('process.js');
referenceTemplateFile('utils.js');

var environmentFile = indexJS.createReferencedFile(outputDir + 'environment-data.js');
environmentFile.writeline('/* global intellisense */');
environmentFile.writeline('// This file is generated by vs-nodesense.');
environmentFile.writeAssignment('process.arch', process.arch);
environmentFile.writeAssignment('process.platform', process.platform);
environmentFile.writeAssignment('process.version', process.version);
environmentFile.writeAssignment('process.env', process.env);
environmentFile.writeAssignment('process.versions', process.versions);
environmentFile.writeAssignment('process.config', process.config);
environmentFile.writeline('intellisense.deleteExtraGlobals(' + JSON.stringify(nodeGlobals) + ');');
environmentFile.end();


// This order is as close to a topological sort as I can get.
// Otherwise, native modules that inherit other modules won't
// work, since their dependencies won't have been defined. To
// debug this, disable declareModule(), then read JSLS output
// to see which modules were loaded before being defined.
var knownModuleOrder = [
	'util', 'events', 'assert', '_stream_readable', '_stream_writable', '_stream_duplex', '_stream_transform',
	'_stream_passthrough', 'stream', '_linklist', 'timers', 'net', 'path', 'querystring', 'punycode', 'url',
	'string_decoder', 'crypto', 'tls', 'dgram', 'vm', 'child_process'
];

// TODO: Add node_modules aliases
_(process.binding('natives'))
	.pairs()
	.sortBy(function (pair) {
		var index = knownModuleOrder.indexOf(pair[0]);
		return index < 0 ? 9999 : index;
	})
	.forEach(function (p) {
		var name = p[0], source = p[1];
		var filePath = builtinsDir + name + '.js';

		// We don't need to wait for the file to be written
		fs.writeFile(filePath, source);
		refGen.emitFile(name, filePath);
	});

refGen.end();
indexJS.end();